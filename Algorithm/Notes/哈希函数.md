### 哈希函数 
1. 输入域 无穷 输出有限  
   
   MD5 0 ~ 2^64 - 1 
   
   SHA1 0 ~ 2^128 - 1   

2. same in -> same out
   
   不随机

3. dif in -> same out 
   
   不同输入可能有同一输出  哈希碰撞 概率很低

4. 离散性和均匀性都好 同一大小不同区域取的数目都差不多 取模后也能保持其均匀离散

#### 1G内存表示 无符号数 

无符号数 有 1 ~ 2^32 - 1

用 哈希表 一条 4*2 bit 不够

通过 mod 把 a1 -> b1 再模 100 发到 100 个种类文件里 因为还是均匀的

### 哈希表 

输入 先 hash 然后 mod 找位置 

用 单向链表挂上去 

如果单向链表太长了 扩容 mod 的大小

扩容代价 N个字符串 最差扩容 logN 次 扩容代价 N

总 N * logN 单次 logN

1. 控制 链长度 N
2. 离线扩容  使用时jvm扩容到一块新的地方

使用时 O1 理论logN

### 布隆过滤器

黑名单 爬虫去重过滤 

100亿的大列表 判断能不能通过 只有加入 查询 无删

哈希表 内存占用太大 

布隆过滤器 内存占用少 可能有一定失误 万分之一

失误出现情况：
   1. 黑 -> 白 no 不会出现
   2. 白 -> 黑 ok 一定会出现 

bitmap bitarr

```java
public class Code05_BitMap {

	public static void main(String[] args) {

		
		int a = 0;
				
		// a  32 bit
		
		
		int[] arr = new int[10]; // 32bit * 10 -> 320 bits
		
		// arr[0]  int  0  ~ 31
		// arr[1]  int  32 ~ 63
		// arr[2]  int  64 ~ 95
		
		

		int i = 178; // 想取得178个bit的状态
		
		
		
		
		
		int numIndex = i / 32;
		int bitIndex = i % 32;
		
		// 拿到178位的状态
		int s = (      (arr[numIndex] >> (bitIndex))        & 1);
		
		
		
		
        // 请把178位的状态改成1

		arr[numIndex] = arr[numIndex] | (1 << (bitIndex));

		
		
		
		
		i = 178; // 请把178位的状态改成0

		arr[numIndex] = arr[numIndex] & (~   (1 << bitIndex)  );

		
		
		
		
		i = 178; // 请把178位的状态拿出来

		// bit 0 1
		int bit = (arr[i / 32] >> (i % 32)) & 1;

	}

}
```
