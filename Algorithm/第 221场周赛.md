### 5637. 判断字符串的两半是否相似
给你一个偶数长度的字符串 s 。将其拆分成长度相同的两半，前一半为 a ，后一半为 b 。

两个字符串 相似 的前提是它们都含有相同数目的元音（'a'，'e'，'i'，'o'，'u'，'A'，'E'，'I'，'O'，'U'）。

注意，s 可能同时含有大写和小写字母。

如果 a 和 b 相似，返回 true ；否则，返回 false 。
***
### 思路
没啥好讲的，直接模拟

### Code
```java
class Solution {
    public boolean halvesAreAlike(String s) {
        Set<Character> set = new HashSet<>();
        set.add('a');
        set.add('e');
        set.add('i');
        set.add('o');
        set.add('u');
        set.add('A');
        set.add('E');
        set.add('I');
        set.add('O');
        set.add('U');
        int n = s.length(), count1 = 0, count2 = 0;
        for (int i = 0; i < n; i++) {
            char c = s.charAt(i);
            if (i < n / 2 && set.contains(c)) count1++;
            else if (i >= n / 2 && set.contains(c)) count2++;
        }
        return count1 == count2;
    }
}
```
***
### 5210. 球会落何处
用一个大小为 m x n 的二维网格 grid 表示一个箱子。你有 n 颗球。箱子的顶部和底部都是开着的。

箱子中的每个单元格都有一个对角线挡板，跨过单元格的两个角，可以将球导向左侧或者右侧。

- 将球导向右侧的挡板跨过左上角和右下角，在网格中用 1 表示。
- 将球导向左侧的挡板跨过右上角和左下角，在网格中用 -1 表示。

在箱子每一列的顶端各放一颗球。每颗球都可能卡在箱子里或从底部掉出来。如果球恰好卡在两块挡板之间的 "V" 形图案，或者被一块挡导向到箱子的任意一侧边上，就会卡住。

返回一个大小为 n 的数组 answer ，其中 answer[i] 是球放在顶部的第 i 列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回 -1 。


示例 1：

输入：

grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]

输出：

[1,-1,-1,-1,-1]

解释：

示例如图：
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/12/26/ball.jpg)
b0 球开始放在第 0 列上，最终从箱子底部第 1 列掉出。

b1 球开始放在第 1 列上，会卡在第 2、3 列和第 1 行之间的 "V" 形里。

b2 球开始放在第 2 列上，会卡在第 2、3 列和第 0 行之间的 "V" 形里。

b3 球开始放在第 3 列上，会卡在第 2、3 列和第 0 行之间的 "V" 形里。

b4 球开始放在第 4 列上，会卡在第 2、3 列和第 1 行之间的 "V" 形里。
示例 2：

输入：grid = [[-1]]

输出：[-1]

解释：球被卡在箱子左侧边上。

提示：
- m == grid.length
- n == grid[i].length
- 1 <= m, n <= 100
- grid[i][j] 为 1 或 -1

***
### 思路
卡住的情况就三种
   - 边界上 
    
    1. 左边界-1
    
    2. 右边界1   
   - 中间V字 相邻的 [1,-1]
  
  没卡住就进行移动 球向左or向右移动到下一层
 
  状态转移
  - 右移 gird[i][j]==1 && j<col-1 && gird[i][j+1]==1
  - 左移 gird[i][j]==-1 && j>0 && gird[i][j-1]==-1
  
  ~~写状态j的约束条件要写在前面不然j+1和j-1就错了~~
  
### Code
```java
  class Solution {
        public int[] findBall(int[][] grid) {
            int row = grid.length, col = grid[0].length;
            int[] ans = new int[col];
            for (int i = 0; i < col; i++) {
                ans[i] = i;
            }
            for (int i = 0; i < row; i++) {
                for (int j = 0; j < col; j++) {
                    if (ans[j] == -1) {
                        continue;
                    }
                    if (grid[i][ans[j]] == 1 && (ans[j] < col - 1) && grid[i][ans[j] + 1] == 1) {
                        ans[j]++;
                    } else if (grid[i][ans[j]] == -1 && (ans[j] >0) && grid[i][ans[j] - 1] == -1) {
                        ans[j]--;
                    } else {
                        ans[j] = -1;
                    }
                }
            }
            return ans;
        }
    }
```