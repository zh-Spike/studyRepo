### 题目
当 A 的子数组 A[i], A[i+1], ..., A[j] 满足下列条件时，我们称其为湍流子数组：

- 若 i <= k < j，当 k 为奇数时， A[k] > A[k+1]，且当 k 为偶数时，A[k] < A[k+1]；
- 或 若 i <= k < j，当 k 为偶数时，A[k] > A[k+1] ，且当 k 为奇数时， A[k] < A[k+1]。
也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。

返回 A 的最大湍流子数组的长度。

示例 1：
```
输入：[9,4,2,10,7,8,8,1,9]
输出：5
解释：(A[1] > A[2] < A[3] > A[4] < A[5])
```
示例 2：
```
输入：[4,8,12,16]
输出：2
```
示例 3：
```
输入：[100]
输出：1
```

提示：

- 1 <= A.length <= 40000
- 0 <= A[i] <= 10^9

### 思路

其实主要是判断两个相邻符号的连续性

最简单的做法就是开一个数组 把符号记录下去 然后判一下是否满足条件即可 空间就会比较费

还有个想法是 只判断三个连续的数字的符号 然后看符不符合条件 然后记录长度 取最大长度的

结合一下 算出当前符号 判断一下 再算下一个 比较一下 

符号不同 r++ 如果符号相同 l 移动到 r 前面

不过有特殊情况就是 遇到两个值相等的情况

由题意 如果是两个连在一起的 那 l 移动到 r 的位置

感觉有点像 HDB3 码中的 B00V 破坏脉冲
### Code
```java
    class Solution {
        public int maxTurbulenceSize(int[] arr) {
            int l = 0, r = 1, len = arr.length;
            if (len < 2) return len;
            int res = 1, pre = 0;
            while (r < len) {
                // 判断当前符号 > 就是 1
                // < 就是0
                int cur = arr[r] - arr[r - 1] > 0 ? 1 : 0;
                // 两个如果是 同号的 那个就 l 移动到 r 前面 长度重新从 1 统计 保留上次的符号状态
                if (cur == pre) l = r - 1;
                // 出现两个连续值相等的情况 长度归 0 重新判断符号 
                if (arr[r - 1] == arr[r]) l = r;
                r++;
                res = Math.max(res, r - l);
                pre = cur;
            }
            return res;
        }
    }
```
*** 
### 收获
