- [哈希函数](#哈希函数)
	- [1G内存表示 无符号数](#1g内存表示-无符号数)
- [哈希表](#哈希表)
- [布隆过滤器](#布隆过滤器)
- [一致性哈希](#一致性哈希)
### 哈希函数 
1. 输入域 无穷 输出有限  
   
   MD5 0 ~ 2^64 - 1 
   
   SHA1 0 ~ 2^128 - 1   

2. same in -> same out
   
   不随机

3. dif in -> same out 
   
   不同输入可能有同一输出  哈希碰撞 概率很低

4. 离散性和均匀性都好 同一大小不同区域取的数目都差不多 取模后也能保持其均匀离散

#### 1G内存表示 无符号数 

无符号数 有 1 ~ 2^32 - 1

用 哈希表 一条 4*2 bit 不够

通过 mod 把 a1 -> b1 再模 100 发到 100 个种类文件里 因为还是均匀的

### 哈希表 

输入 先 hash 然后 mod 找位置 

用 单向链表挂上去 

如果单向链表太长了 扩容 mod 的大小

扩容代价 N个字符串 最差扩容 logN 次 扩容代价 N

总 N * logN 单次 logN

1. 控制 链长度 N
2. 离线扩容  使用时jvm扩容到一块新的地方

使用时 O1 理论logN

### 布隆过滤器

黑名单 爬虫去重过滤 

100亿的大列表 判断能不能通过 只有加入 查询 无删

哈希表 内存占用太大 

布隆过滤器 内存占用少 可能有一定失误 万分之一

失误出现情况：
   1. 黑 -> 白 no 不会出现
   2. 白 -> 黑 ok 一定会出现 

bitmap bitarr

```java
public class Code05_BitMap {

	public static void main(String[] args) {

		
		int a = 0;
				
		// a  32 bit
		
		
		int[] arr = new int[10]; // 32bit * 10 -> 320 bits
		
		// arr[0]  int  0  ~ 31
		// arr[1]  int  32 ~ 63
		// arr[2]  int  64 ~ 95
		
		

		int i = 178; // 想取得178个bit的状态
		
		
		
		
		
		int numIndex = i / 32;
		int bitIndex = i % 32;
		
		// 拿到178位的状态
		int s = (      (arr[numIndex] >> (bitIndex))        & 1);
		
		
		
		
        // 请把178位的状态改成1

		arr[numIndex] = arr[numIndex] | (1 << (bitIndex));

		
		
		
		
		i = 178; // 请把178位的状态改成0

		arr[numIndex] = arr[numIndex] & (~   (1 << bitIndex)  );

		
		
		
		
		i = 178; // 请把178位的状态拿出来

		// bit 0 1
		int bit = (arr[i / 32] >> (i % 32)) & 1;

	}

}
```
影响误判的是 位图开的大小 m的大小 

单样本大小和布隆过滤器没关系 

n 样本辆 P 失误率

m = - ( n * lnP ) / (（ ln2 ）^2 ) 位图大小

k = ( ln2 * m/n )  = 0.7 * m / m 算哈希函数个数

P实际 = ( 1 - e ^(-( n * k ) / m真 )) ^k真 <= 设计的P失误率


### 一致性哈希

分布式

数据 哈希一下 取模 对应到数据服务器

哈希key 的设计 要取一些特殊的 种类比较多 让高中低频都有差不多数量 这样才能均分

不能是 国家 性别 这种

经典设计 数据迁移 (加台新机器) 全量


优化：

	1. 数据端的服务器的 mac等唯一的信息 通过MD5哈希 把他们位置 搞成一个哈希环 

		记录到逻辑端服务器 然后你数据进来 哈希后找在环上 最近的服务器 （顺时针）

	2. 加减机器代价少 


问题： 
	
	1. 机器少的时候 环难均分

	2， 加机器过后环不均分了

解决：

   	虚拟节点:
    
     	即将每台物理服务器虚拟为一组虚拟服务器，将虚拟服务器放置到哈希环上，
		
		如要确定对象的服务器，需先确定对象的虚拟服务器，再由虚拟服务器确定物理服务器。

		如果要增删 那就重新映射虚拟节点即可 虚拟节点均匀分布在哈希环上

