### 题目

序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。
```
     _9_
    /   \
   3     2
  / \   / \
 4   1  #  6
/ \ / \   / \
# # # #   # #
```
例如，上面的二叉树可以被序列化为字符串 "9,3,4,#,#,1,#,#,2,#,6,#,#"，其中 # 代表一个空节点。

给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。

每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 '#' 。

你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 "1,,3" 。

示例 1:
```
输入: "9,3,4,#,#,1,#,#,2,#,6,#,#"
输出: true
```
示例 2:
```
输入: "1,#"
输出: false
```
示例 3:
```
输入: "9,#,#,1"
输出: false
```

链接：https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree

### 思路

首先 光靠先序遍历是不能重构二叉树的

就是个找规律的题

每一个非空节点都对应了 2 个出度，空节点都对应了 0 个出度；除了根节点，每个节点都有一个入度。

同时，一颗合格的二叉树最终结果必然满足 in == out。

但我们又不能只利用最终 in == out 来判断是否合法，这很容易可以举出反例：考虑将一个合法序列的空节点全部提前，这样最终结果仍然满足 in == out，但这样的二叉树是不存在的。

一颗合格二叉树 m 和 n 的最小的比例关系是 1 : 2 

```
 4 
/ \
# #
```

二叉树空节点总是跟在非空节点的后面这一性质。

在没到最后一个节点之前，我们是不会遇到 空节点数量 > 非空节点数量 的情况的。

非空节点数量 >= 空节点数量 在遍历没结束前恒成立：m>=n


### Code
```java
        public boolean isValidSerialization(String s) {
            String[] ss = s.split(",");
            int n = ss.length;
            int in = 0, out = 0;
            for (int i = 0; i < n; i++) {
                // 碰到 空 增加两个 out
                if (!ss[i].equals("#")) {
                    out += 2;
                }
                // 非根节点都有一个 in
                if (i != 0) {
                    in++;
                }
                // 如果 到根节点了 in >= out
                // 那他就是不满足的
                if (i != n - 1 && out <= in) {
                    return false;
                }
            }
            return in == out;
        }
    }
```
链接：https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/solution/xiang-xin-ke-xue-xi-lie-xiang-jie-zhi-gu-e3y9/
*** 

### 收获
